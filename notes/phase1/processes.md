# Phase 1: プロセス管理

## MINIX 3のプロセス構造体

MINIX 3の `kernel/proc.h` で定義されている `struct proc` を学んだ。

### 構造体の主要なフィールド

```c
struct proc {
  struct stackframe_s p_reg;    // 保存されたレジスタ
  proc_nr_t p_nr;               // プロセス番号
  char p_rts_flags;             // 実行状態フラグ
  char p_priority;              // 現在の優先度
  char p_max_priority;          // 最大優先度
  char p_ticks_left;            // 残り時間量子
  char p_quantum_size;          // 時間量子サイズ
  struct proc *p_nextready;     // 次の準備完了プロセス
  message *p_messbuf;           // IPCメッセージバッファ
  char p_name[P_NAME_LEN];      // プロセス名
};
```

### MikanOSとの比較

| 項目 | MikanOS | MINIX 3 |
|------|---------|---------|
| タスク構造体 | `struct TaskContext` | `struct proc` |
| スケジューリング | ラウンドロビン | 優先度ベース |
| 優先度 | なし | 16段階（0=最高） |
| 時間量子 | なし | あり（`p_ticks_left`） |
| IPC | メッセージパッシング | `send()`/`receive()` |

---

## 質問1: 構造体の中に「関数がある」について

### 質問
「関数？構造体？構造体の中にも関数がある？」

### 回答

Rustでは**構造体に関連する関数**を定義できます。これを**メソッド**と呼びます。

```rust
// 構造体の定義
pub struct ProcessFlags(u8);

// impl ブロックの中に「この構造体に関連する関数」を書く
impl ProcessFlags {
    // これは「関連関数」（staticメソッドのようなもの）
    // Self は ProcessFlags のこと
    pub const fn new() -> Self {
        Self(0)  // ProcessFlags(0) と同じ意味
    }
    
    // これは「メソッド」（self を取る）
    // &self は「自分自身への参照」
    pub fn is_runnable(&self) -> bool {
        self.0 == 0  // self.0 は中の u8 値
    }
}
```

**C言語との比較：**
```c
// C言語の場合
struct ProcessFlags {
    uint8_t value;
};

// 関数は外で定義
ProcessFlags process_flags_new() {
    ProcessFlags pf;
    pf.value = 0;
    return pf;
}

bool process_flags_is_runnable(ProcessFlags* self) {
    return self->value == 0;
}
```

```rust
// Rustの場合
let mut flags = ProcessFlags::new();     // 関連関数
let runnable = flags.is_runnable();       // メソッド
```

### self の種類

| 書き方 | 意味 |
|--------|------|
| `&self` | 読み取り専用 |
| `&mut self` | 読み書き可能 |
| `self` | 所有権を移動 |

---

## 質問2: 8ビット整数で管理する理由

### 質問
「8ビットの整数で管理する理由は？図示してよりわかりやすく説明して」

### 回答

### 8ビットとは？

```
8ビット = 8つの0と1の並び

例: 0 1 0 0 0 1 0 0
    ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
    ビット7〜ビット0
```

**8ビットで表せる数：**
- 0 〜 255（全部で256通り）
- 2⁸ = 256

---

### なぜ8ビットで状態を管理するのか？

**1つの整数で「複数の状態」を同時に表せるから！**

```
┌─────────────────────────────────────────────────────┐
│  8ビットの各ビットに「意味」を割り当てる              │
├─────────────────────────────────────────────────────┤
│                                                     │
│    ビット番号:  7   6   5   4   3   2   1   0       │
│                ┌───┬───┬───┬───┬───┬───┬───┬───┐   │
│    値:         │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │   │
│                └───┴───┴───┴───┴───┴───┴───┴───┘   │
│                              ↑       ↑   ↑         │
│                              │       │   │         │
│                    受信待ち ─┘       │   └─ スロット空き │
│                              送信待ち ─┘              │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### 状態のパターン例

#### パターンA: 何も待っていない（実行可能）

```
    ビット番号:  7   6   5   4   3   2   1   0
                ┌───┬───┬───┬───┬───┬───┬───┬───┐
    値:         │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │   = 0
                └───┴───┴───┴───┴───┴───┴───┴───┘
                
    → すべて0 = 実行可能！
```

#### パターンB: 送信待ち

```
    ビット番号:  7   6   5   4   3   2   1   0
                ┌───┬───┬───┬───┬───┬───┬───┬───┐
    値:         │ 0 │ 0 │ 0 │ 0 │ 0 │ 1 │ 0 │ 0 │   = 4
                └───┴───┴───┴───┴───┴───┴───┴───┘
                                          ↑
                                    ビット2が1
                                    
    → 送信待ち状態
```

#### パターンC: 送信待ち AND 受信待ち

```
    ビット番号:  7   6   5   4   3   2   1   0
                ┌───┬───┬───┬───┬───┬───┬───┬───┐
    値:         │ 0 │ 0 │ 0 │ 0 │ 1 │ 1 │ 0 │ 0 │   = 12
                └───┴───┴───┴───┴───┴───┴───┴───┘
                                  ↑   ↑
                            ビット3  ビット2
                            
    → 複数の状態を同時に表現！
```

---

### 8ビットフラグ管理のメリットまとめ

```
┌─────────────────────────────────────────────────────────┐
│                   8ビットフラグ管理                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   メリット1: 1つの変数で複数の状態を管理                 │
│   ┌───┬───┬───┬───┬───┬───┬───┬───┐                    │
│   │ ? │ ? │ ? │ ? │受信│送信│ ? │空き│                   │
│   └───┴───┴───┴───┴───┴───┴───┴───┘                    │
│                                                         │
│   メリット2: 高速な演算                                  │
│   - ビット演算はCPUが直接実行                           │
│   - 足し算・引き算より速い                              │
│                                                         │
│   メリット3: メモリ節約                                  │
│   - 8つの状態を1バイトで管理                            │
│   - bool 8個 = 8バイト → ビットフラグ = 1バイト         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 質問3: 0x（16進数）で管理できるのはなぜ？

### 質問
「0xで管理できるのはなぜ？わかりやすく」

### 回答

**0x = 16進数（ hexadecimal）の意味**

### 10進数 vs 2進数 vs 16進数

```
┌──────────┬────────────────────┬──────────┐
│  10進数  │      2進数         │  16進数  │
├──────────┼────────────────────┼──────────┤
│    0     │ 0000 0000          │   0x00   │
│    1     │ 0000 0001          │   0x01   │
│    4     │ 0000 0100          │   0x04   │
│    8     │ 0000 1000          │   0x08   │
│   12     │ 0000 1100          │   0x0C   │
│   15     │ 0000 1111          │   0x0F   │
│  255     │ 1111 1111          │   0xFF   │
└──────────┴────────────────────┴──────────┘
```

### 16進数が便利な理由

**2進数と16進数の対応がきれい！**

```
    2進数:     1111 0011
               ↓↓↓↓ ↓↓↓↓
    16進数:      F    3
    
    → 4ビットずつ区切ると、1文字で表せる！
```

```
    16進数の文字:
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
    ↑                                        ↑
    0                                        15
```

### どのビットが立っているか一目でわかる

```
    0x01 = 0000 0001  → ビット0
    0x02 = 0000 0010  → ビット1
    0x04 = 0000 0100  → ビット2  ← 4 = 2²
    0x08 = 0000 1000  → ビット3  ← 8 = 2³
    0x10 = 0001 0000  → ビット4  ← 16 = 2⁴
    0x20 = 0010 0000  → ビット5  ← 32 = 2⁵
```

---

## 質問4: 0x02の変数を用意していないのはなぜ？

### 質問
「`pub const SLOT_FREE: u8 = 0x01;` について、0x02の変数を用意していないのはなぜ？」

### 回答

### MINIX 3の実際の定義

```c
// MINIX 3 kernel/proc.h
#define SLOT_FREE   0x01  // ビット0: スロット空き
#define NO_MAP      0x02  // ビット1: メモリマップなし
#define SENDING     0x04  // ビット2: 送信待ち
#define RECEIVING   0x08  // ビット3: 受信待ち
```

### `NO_MAP` とは？

```
┌─────────────────────────────────────────────────────┐
│  NO_MAP = 0x02 (ビット1)                             │
├─────────────────────────────────────────────────────┤
│                                                     │
│  「メモリマップがまだ設定されていない」状態          │
│                                                     │
│  いつ使う？                                          │
│  - fork()した直後の子プロセス                        │
│  - メモリ領域がまだ割り当てられていない              │
│  - 実行しようとするとクラッシュする                  │
│                                                     │
│  ビット番号:  7   6   5   4   3   2   1   0         │
│              ┌───┬───┬───┬───┬───┬───┬───┬───┐     │
│  値:         │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 1 │ 0 │     │
│              └───┴───┴───┴───┴───┴───┴───┴───┘     │
│                                        ↑           │
│                                   ビット1 = NO_MAP  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### なぜ最初は省略したか

**学習を段階的に進めるため！**

```
┌─────────────────────────────────────────────────────┐
│  Phase 1 の実装では、まず基本機能だけ実装            │
├─────────────────────────────────────────────────────┤
│                                                     │
│  最初に実装:                                         │
│  ✓ SLOT_FREE  (0x01) - プロセススロットが空き       │
│  ✓ SENDING    (0x04) - IPC送信待ち                  │
│  ✓ RECEIVING  (0x08) - IPC受信待ち                  │
│                                                     │
│  後で追加予定:                                       │
│  ✗ NO_MAP     (0x02) - メモリマップ未設定           │
│  ✗ SIGNALED   (0x10) - シグナル受信                 │
│  ✗ SIG_PENDING(0x20) - シグナル処理中               │
│  ✗ P_STOP     (0x40) - デバッグ用停止               │
│  ✗ NO_PRIV    (0x80) - 権限なし                     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 16進数とビットの対応表

```
┌─────────┬───────────┬────────────────────────────────┐
│ 16進数  │  2進数    │ ビット位置                      │
├─────────┼───────────┼────────────────────────────────┤
│  0x01   │ 0000 0001 │ ビット0 ← SLOT_FREE            │
│  0x02   │ 0000 0010 │ ビット1 ← NO_MAP               │
│  0x04   │ 0000 0100 │ ビット2 ← SENDING              │
│  0x08   │ 0000 1000 │ ビット3 ← RECEIVING            │
│  0x10   │ 0001 0000 │ ビット4 ← SIGNALED             │
│  0x20   │ 0010 0000 │ ビット5 ← SIG_PENDING          │
│  0x40   │ 0100 0000 │ ビット6 ← P_STOP               │
│  0x80   │ 1000 0000 │ ビット7 ← NO_PRIV              │
└─────────┴───────────┴────────────────────────────────┘

法則: 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
      = 2⁰, 2¹, 2², 2³, 2⁴, 2⁵, 2⁶, 2⁷
```

---

## ビット演算の図解

### OR演算（`|`）= フラグを立てる

```
    現在の状態:  0000 0000  (何も待っていない)
    OR する値:   0000 0100  (SENDING)
                 ────────
    結果:        0000 0100  (送信待ちになった！)
```

### AND演算（`&`）= フラグを確認

```
    現在の状態:  0000 1100  (送信待ち & 受信待ち)
    AND する値:  0000 0100  (SENDING)
                 ────────
    結果:        0000 0100  (0でない = SENDINGが立っている)
```

### NOT演算（`!`）+ AND = フラグを下ろす

```
    現在の状態:  0000 1100
    NOT(SENDING):1111 1011  (SENDINGのビットだけ0)
    AND:         ────────
    結果:        0000 1000  (SENDINGが消えた！)
```

---

## Rustでの実装

### 1. プロセス状態フラグ（ProcessFlags）

```rust
pub struct ProcessFlags(u8);

impl ProcessFlags {
    // ===== Phase 1: プロセス管理で使用 =====
    /// ビット0: スロットは空き
    pub const SLOT_FREE: u8 = 0x01;
    /// ビット2: 送信待ち
    pub const SENDING: u8 = 0x04;
    /// ビット3: 受信待ち
    pub const RECEIVING: u8 = 0x08;
    
    // ===== Phase 3: メモリ管理で使用 =====
    // /// ビット1: メモリマップ未設定（fork直後の子プロセス）
    // pub const NO_MAP: u8 = 0x02;
    
    // ===== Phase 4: ファイルシステムで使用 =====
    // /// ビット4: シグナル受信
    // pub const SIGNALED: u8 = 0x10;
    // /// ビット5: シグナル処理中
    // pub const SIG_PENDING: u8 = 0x20;
    
    // ===== 発展: デバッグ・権限管理で使用 =====
    // /// ビット6: デバッグ用停止
    // pub const P_STOP: u8 = 0x40;
    // /// ビット7: 権限なし
    // pub const NO_PRIV: u8 = 0x80;
}
```

#### コードと状態の対応

| コード | 2進数 | 状態 |
|--------|-------|------|
| `ProcessFlags::new()` | `0000 0000` | 実行可能 |
| `flags.set(SLOT_FREE)` | `0000 0001` | スロット空き |
| `flags.set(NO_MAP)` | `0000 0010` | メモリマップ未設定 |
| `flags.set(SENDING)` | `0000 0100` | 送信待ち |
| `flags.set(RECEIVING)` | `0000 1000` | 受信待ち |
| `SENDING \| RECEIVING` | `0000 1100` | 送信待ち & 受信待ち |

---

### 2. 優先度（Priority）

```rust
pub struct Priority(u8);

impl Priority {
    pub const TASK_Q: u8 = 0;   // カーネルタスク（最高）
    pub const USER_Q: u8 = 7;   // ユーザープロセス
    pub const IDLE_Q: u8 = 15;  // アイドル（最低）
}
```

#### コードと状態の対応

| コード | 値 | 状態 |
|--------|-----|------|
| `Priority::new(Priority::TASK_Q)` | 0 | カーネルタスク（最優先） |
| `Priority::new(Priority::USER_Q)` | 7 | 通常のユーザープロセス |
| `Priority::new(Priority::IDLE_Q)` | 15 | アイドルプロセス（最低） |

**MINIX 3の考え方：** 数値が小さいほど優先度が高い

---

### 3. レジスタ保存領域（StackFrame）

```rust
#[repr(C)]
pub struct StackFrame {
    pub rax: u64, pub rbx: u64, pub rcx: u64, pub rdx: u64,
    pub rsi: u64, pub rdi: u64, pub rbp: u64,
    pub r8: u64, pub r9: u64, pub r10: u64, pub r11: u64,
    pub r12: u64, pub r13: u64, pub r14: u64, pub r15: u64,
    pub rflags: u64,  // フラグレジスタ
    pub rip: u64,     // プログラムカウンタ
    pub rsp: u64,     // スタックポインタ
}
```

#### 各フィールドの意味

| フィールド | 意味 | 用途 |
|-----------|------|------|
| `rax`〜`r15` | 汎用レジスタ | 計算結果、引数など |
| `rflags` | CPUフラグ | ゼロフラグ、キャリーフラグなど |
| `rip` | 命令ポインタ | 次に実行する命令のアドレス |
| `rsp` | スタックポインタ | スタックの先頭アドレス |

**用途：** コンテキストスイッチ時にレジスタを保存・復元

---

### 4. プロセス構造体（Process）

```rust
pub struct Process {
    pub registers: StackFrame,   // 保存されたレジスタ
    pub pid: ProcessId,          // プロセスID
    pub flags: ProcessFlags,     // 実行状態
    pub priority: Priority,      // 優先度
    pub ticks_left: u8,          // 残り時間量子
    pub quantum_size: u8,        // 時間量子サイズ
    pub name: [u8; 16],          // プロセス名
}
```

#### コードと状態の対応

| コード | 状態 |
|--------|------|
| `Process::new(1)` | PID=1の新しいプロセス |
| `process.is_runnable()` | 実行可能かどうか確認 |
| `process.set_name("init")` | プロセス名を設定 |

---

## Rustの文法メモ

### impl ブロック

構造体に関連する関数（メソッド）を定義：

```rust
impl Process {
    // 関連関数（コンストラクタ）
    pub fn new(pid: ProcessId) -> Self {
        Self { pid, ... }
    }
    
    // メソッド（読み取り専用）
    pub fn is_runnable(&self) -> bool {
        self.flags.is_runnable()
    }
    
    // メソッド（変更可能）
    pub fn set_name(&mut self, name: &str) {
        // ...
    }
}
```

### const fn

コンパイル時に実行できる関数。グローバル変数の初期化に使用。

### #[derive(...)]

機能を自動実装：
- `Debug` → デバッグ表示可能
- `Clone` → `.clone()` 可能
- `Copy` → 自動コピー

### タプル構造体

```rust
pub struct Priority(u8);  // フィールド名なし
let p = Priority::new(7);
let value = p.0;  // .0 でアクセス
```

---

## 次のステップ

- [ ] コンテキストスイッチの実装
- [ ] スケジューラの実装
- [ ] IPC（メッセージパッシング）の実装

---

## 質問6: OSのコンテキストとAIのコンテキストの違い

### 質問
「OSにおけるコンテキストの概念について、AIにおけるコンテキストの概念と比較しながら説明して」

### 回答

### OSのコンテキスト

```
┌─────────────────────────────────────────────────────┐
│  OSのコンテキスト = CPUの状態                       │
├─────────────────────────────────────────────────────┤
│                                                     │
│  「どこまで実行したか」を保存するデータ              │
│                                                     │
│  - レジスタの値（rax, rbx, rip, rsp...）           │
│  - スタックポインタ                                 │
│  - プログラムカウンタ（次の命令アドレス）           │
│                                                     │
│  用途: プロセス切り替え時に保存・復元               │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### AIのコンテキスト

```
┌─────────────────────────────────────────────────────┐
│  AIのコンテキスト = 会話の状態                      │
├─────────────────────────────────────────────────────┤
│                                                     │
│  「どこまで話したか」を保存するデータ               │
│                                                     │
│  - 過去のメッセージ履歴                             │
│  - ユーザーの指示                                   │
│  - 学習した内容                                     │
│                                                     │
│  用途: 会話の継続、一貫性の維持                     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### 比較表

| 項目 | OSのコンテキスト | AIのコンテキスト |
|------|-----------------|-----------------|
| **本体** | CPUのレジスタ | 会話履歴 |
| **保存タイミング** | プロセス切り替え時 | 毎回のやり取り |
| **復元タイミング** | プロセス再開時 | 次の質問時 |
| **サイズ** | 数KB（レジスタ数） | 数MB〜（トークン数） |
| **目的** | マルチタスク | 会話の継続性 |
| **切り替え速度** | ナノ秒 | ミリ秒〜秒 |

---

### 図解：コンテキストスイッチ

#### OSのコンテキストスイッチ

```
  プロセスA実行中                    プロセスB実行中
       │                                  ▲
       │ コンテキスト保存                  │
       │ (レジスタ → メモリ)               │
       ▼                                  │
  ┌─────────┐                      ┌─────────┐
  │ Context │ ──切り替え──→       │ Context │
  │   A     │                      │   B     │
  └─────────┘                      └─────────┘
       │                                  │
       │ コンテキスト復元                  │
       │ (メモリ → レジスタ)               │
       ▼                                  │
    一時停止                           再開
```

#### AIのコンテキストスイッチ

```
  ユーザーAとの会話                   ユーザーBとの会話
       │                                  ▲
       │ 会話履歴保存                      │
       │ (履歴 → データベース)             │
       ▼                                  │
  ┌─────────┐                      ┌─────────┐
  │ Context │ ──切り替え──→       │ Context │
  │   A     │                      │   B     │
  └─────────┘                      └─────────┘
       │                                  │
       │ 会話履歴復元                      │
       │ (データベース → 履歴)             │
       ▼                                  │
    一時停止                           再開
```

---

### 共通点

```
┌─────────────────────────────────────────────────────┐
│  どちらも「状態を保存して後で復元する」仕組み       │
├─────────────────────────────────────────────────────┤
│                                                     │
│  1. 状態の保存（Save）                              │
│     OS: レジスタをメモリに保存                     │
│     AI: 会話履歴をデータベースに保存               │
│                                                     │
│  2. 状態の復元（Restore）                           │
│     OS: メモリからレジスタに復元                   │
│     AI: データベースから会話履歴を復元             │
│                                                     │
│  3. 切り替え（Switch）                              │
│     OS: プロセスA → プロセスB                      │
│     AI: ユーザーA → ユーザーB                      │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## MINIX 3での概念の解説

### stackframe_s（レジスタ保存領域）

MINIX 3では `kernel/type.h` で定義：

```c
struct stackframe_s {           /* proc_ptr points here */
  u16_t gs;                     /* セグメントレジスタ */
  u16_t fs;
  u16_t es;
  u16_t ds;
  reg_t di;			/* 汎用レジスタ */
  reg_t si;
  reg_t fp;			/* bp (ベースポインタ) */
  reg_t st;			/* sp (スタックポインタ) */
  reg_t bx;
  reg_t dx;
  reg_t cx;
  reg_t retreg;			/* ax (戻り値レジスタ) */
  reg_t retadr;			/* 戻りアドレス */
  reg_t pc;			/* プログラムカウンタ (IP) */
  reg_t cs;                     /* コードセグメント */
  reg_t psw;                    /* プロセッサステータスワード (FLAGS) */
  reg_t sp;                     /* スタックポインタ */
  reg_t ss;                     /* スタックセグメント */
};
```

**MINIX 3の設計思想：**
- 割り込み発生時にCPUが自動的にプッシュするレジスタ
- `save()` アセンブリ関数が追加でプッシュ
- コンテキストスイッチで丸ごと保存・復元

---

### mem_map（メモリマップ）

MINIX 3では `include/minix/type.h` で定義：

```c
/* Memory map for local text, stack, data segments. */
struct mem_map {
  vir_clicks mem_vir;		/* 仮想アドレス */
  phys_clicks mem_phys;		/* 物理アドレス */
  vir_clicks mem_len;		/* 長さ */
};
```

**各プロセスは3つのセグメントを持つ：**

```c
// include/minix/const.h
#define T  0	/* proc[i].mem_map[T] is for text  (コード) */
#define D  1	/* proc[i].mem_map[D] is for data  (データ) */
#define S  2	/* proc[i].mem_map[S] is for stack (スタック) */
```

```
┌─────────────────────────────────────────────────────────────┐
│  MINIX 3のプロセスメモリ構造                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  mem_map[T] (Text)    mem_map[D] (Data)    mem_map[S] (Stack)│
│  ┌──────────┐        ┌──────────┐        ┌──────────┐      │
│  │ コード   │        │ データ   │        │ スタック │      │
│  │ (命令)   │        │ (変数)   │        │ (ローカル)│      │
│  │          │        │          │        │    ↓     │      │
│  └──────────┘        └──────────┘        └──────────┘      │
│                                                             │
│  各セグメントは:                                            │
│  - mem_vir: プロセスから見える仮想アドレス                  │
│  - mem_phys: 実際の物理メモリアドレス                       │
│  - mem_len: セグメントのサイズ                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### プロセステーブルの全体像

```c
// kernel/proc.h
struct proc {
  struct stackframe_s p_reg;    // レジスタ保存領域
  proc_nr_t p_nr;               // プロセス番号
  char p_rts_flags;             // 実行状態フラグ
  char p_priority;              // 現在の優先度
  char p_ticks_left;            // 残り時間量子
  struct mem_map p_memmap[3];   // メモリマップ (T, D, S)
  struct proc *p_nextready;     // 次の準備完了プロセス
  message *p_messbuf;           // IPCメッセージバッファ
  char p_name[P_NAME_LEN];      // プロセス名
};
```

---

### MINIX 3と自作OSの対応

| MINIX 3 | 自作OS (Rust) | 役割 |
|---------|---------------|------|
| `struct stackframe_s` | `StackFrame` | レジスタ保存 |
| `struct mem_map[3]` | （未実装） | メモリマップ |
| `p_rts_flags` | `ProcessFlags` | 実行状態 |
| `p_priority` | `Priority` | 優先度 |
| `p_ticks_left` | `ticks_left` | 残り時間量子 |
| `p_nextready` | （未実装） | 次のプロセス |

---

## テスト結果

### 実行日時: 2026-02-21

### テスト数: 20
- 成功: 20
- 失敗: 0

### テスト内容

#### ProcessFlags（6テスト）
- `test_new_flags_are_runnable` - 新しいフラグは実行可能
- `test_set_sending_flag` - SENDINGフラグの設定
- `test_set_receiving_flag` - RECEIVINGフラグの設定
- `test_set_multiple_flags` - 複数フラグの設定
- `test_clear_flag` - フラグのクリア
- `test_slot_free_flag` - SLOT_FREEフラグ

#### Priority（4テスト）
- `test_default_priority` - デフォルト優先度
- `test_task_priority` - TASK_Q（最高優先度）
- `test_idle_priority` - IDLE_Q（最低優先度）
- `test_priority_ordering` - 優先度の比較

#### Process（4テスト）
- `test_new_process` - プロセスの作成
- `test_process_set_name` - 名前の設定
- `test_process_set_long_name` - 長い名前の切り詰め
- `test_process_flags_blocking` - フラグによる実行不可状態

#### ProcessTable（4テスト）
- `test_process_table_creation` - テーブルの作成
- `test_get_mut_out_of_bounds` - 範囲外アクセス
- `test_find_free_slot` - 空きスロット検索
- `test_process_table_modify` - プロセスの変更

#### StackFrame（2テスト）
- `test_stack_frame_new` - ゼロ初期化
- `test_stack_frame_size` - サイズ確認（144バイト）

### テスト実行コマンド

```bash
cd src/kernel && cargo test
```

### #![no_std]環境でのテスト設定

テスト時は標準ライブラリを使用するよう設定：

```rust
#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]

#[cfg(not(test))]
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[cfg(not(test))]
#[no_mangle]
pub extern "C" fn _start() -> ! {
    // ...
}
```

---

作成日: 2026-02-18
