# スタックアンワインド（Stack Unwinding）

## スタックアンワインドとは？

プログラムでエラーやパニックが発生した際、関数呼び出しの履歴（コールスタック）を遡って、各関数のリソースを適切に解放する仕組みです。

## 通常のプログラムでの動作

例：

```rust
fn main() {
    func_a();
}

fn func_a() {
    let _data = vec
![1, 2, 3];
  // メモリ確保
    func_b();
}

fn func_b() {
    panic!("エラー発生"
);  // パニック！
}
```

パニックが発生すると：
1. `func_b` のローカル変数を解放
2. `func_a` に戻り、`_data`（Vec）を解放
3. `main` に戻る
4. プログラムを終了

この「スタックを遡ってリソースを解放」する処理が**スタックアンワインド**です。

## なぜOSカーネルでは使えないのか？

### 1. 標準ライブラリがない
スタックアンワインドにはRustの標準ライブラリが必要。OSカーネルは `#![no_std]` なので使えない。

### 2. メモリ管理が違う
- 通常プログラム：OSがメモリを管理、プロセス終了時にOSが回収
- OSカーネル：自分でメモリを管理

### 3. パフォーマンス
アンワインド機能を有効にするとバイナリサイズとオーバーヘッドが増える。

## panic = "abort" の意味

```toml
[profile.dev]
panic = "abort"
```

「パニックが発生したら、アンワインドせずに即座に停止する」という意味。

| 設定 | パニック時の動作 |
|------|------------------|
| `panic = "unwind"` | スタックアンワインド |
| `panic = "abort"` | 即座に終了 |

## MikanOSでの経験

MikanOSでも同様にパニック時は無限ループやCPU停止をしていたはずです。