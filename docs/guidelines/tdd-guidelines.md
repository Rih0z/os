# テスト駆動開発（TDD）ガイドライン

## TDDのサイクル

1. **Red（失敗するテストを書く）** - まず、これから実装する機能のテストを書く
2. **Green（テストを通す）** - テストをパスする最小限のコードを書く
3. **Refactor（リファクタリング）** - コードを整理・改善する

## なぜTDDなのか

- **設計の改善**: テストを先に書くことで、使いやすいAPIを自然と設計できる
- **自信を持ってリファクタリング**: テストがあることで、変更が既存機能を壊していないか確認できる
- **ドキュメントとしてのテスト**: テストコードは「どう動くべきか」の生きたドキュメント
- **バグの早期発見**: 実装と同時にバグを見つけられる

## RustでのTDD

このプロジェクトはRustを使用しているため、`cargo test` を活用します：

```rust
// 例：テストを先に書く
#[test]
fn test_process_creation() {
    let proc = Process::new(1);
    assert_eq!(proc.pid(), 1);
    assert_eq!(proc.state(), ProcessState::Ready);
}
```

## 実装の進め方

1. **テストを書く** - 実装したい機能のテストを先に書く
2. **コンパイルエラーを確認** - まだ実装していないのでコンパイルエラーになる
3. **最小限の実装** - テストが通る最小限のコードを書く
4. **テストを実行** - `cargo test` で確認
5. **リファクタリング** - 必要に応じてコードを整理
6. **次のテスト** - 次の機能のテストを書く

## AI先生への指示

- 新しい機能を実装する際は、まずテストを書くよう促してください
- テストがない状態での実装は避けてください
- 「テストを書いてから実装しましょう」とガイドしてください

---

## 3エージェント開発システム（TDD強化版）

このプロジェクトでは [three-agent システム](https://github.com/Rih0z/Job-Automate/tree/main/dev/three-agent) のアプローチを採用します。

### コア原則

1. **テストファースト**: 失敗する自動テストを書くことから全作業を始める
2. **イテレーション駆動**: 「目的→テスト戦略→実装→レビュー」を繰り返す
3. **透明性**: 重要な決定・仮定・リスクは必ず文書化する

### ワークフロー

```
┌─────────────────────────────────────────────────────────────┐
│  1. 目的定義                                                │
│     - 何を実装するか                                        │
│     - どういう動作が期待されるか                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  2. テスト戦略                                              │
│     - どんなテストを書くべきか                              │
│     - エッジケースは何か                                    │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  3. テスト実装（Red）                                       │
│     - 失敗するテストを書く                                  │
│     - テストを実行して失敗を確認                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  4. 実装（Green）                                           │
│     - テストをパスする最小限のコード                        │
│     - テストを実行して成功を確認                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  5. リファクタリング                                        │
│     - コードを整理・改善                                    │
│     - テストが通ることを確認                                │
└─────────────────────────────────────────────────────────────┘
                              ↓
                        次のイテレーション
```

### テストの品質基準

各テストは以下を満たすべき：

- **明確な目的**: 何をテストしているか明確
- **自己説明的**: テストコードだけで意図が理解できる
- **独立している**: 他のテストに依存しない
- **再現可能**: 何度実行しても同じ結果

### テスト結果の記録

テスト実行後は、結果をノートに記録する：

```markdown
## テスト結果

- 実行日時: 2026-02-21
- テスト数: 20
- 成功: 20
- 失敗: 0

### テスト内容
- ProcessFlags: フラグの設定・クリア・確認
- Priority: 優先度の作成・比較
- Process: プロセスの作成・名前設定
- ProcessTable: テーブル操作
- StackFrame: レジスタ保存領域
```

---

## #![no_std]環境でのテスト

このプロジェクトはカーネル開発のため `#![no_std]` 環境です。
テスト時は標準ライブラリを使用できるように設定が必要：

```rust
// テスト時は標準ライブラリを使用
#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]

// テスト時は標準ライブラリのpanicハンドラを使用
#[cfg(not(test))]
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

// テスト時はエントリポイントを除外
#[cfg(not(test))]
#[no_mangle]
pub extern "C" fn _start() -> ! {
    // ...
}
```

### テスト実行コマンド

```bash
cd src/kernel && cargo test
```
